name: bpf-ci

on:
  pull_request:
  push:
    branches:
      - bpf_base
      - bpf-next_base

env:
  veristat_arch: x86_64
  veristat_toolchain: gcc

concurrency:
  group: ci-test-${{ github.ref_name }}
  cancel-in-progress: true

jobs:

  set-matrix:
    # FIXME: set-matrix is lightweight, run it on any self-hosted machines for kernel-patches org
    # so we do not wait for GH hosted runners when there potentially all are busy because of bpf-rc
    # repo for instance.
    # This could be somehow fixed long term by making this action/workflow re-usable and letting the called
    # specify what to run on.
    runs-on: ${{ github.repository_owner == 'kernel-patches' && 'x86_64' || 'ubuntu-latest' }}
    outputs:
      build-matrix: ${{ steps.set-matrix-impl.outputs.build_matrix }}
      test-matrix: ${{ steps.set-matrix-impl.outputs.test_matrix }}
      veristat-runs-on: ${{ steps.set-matrix-impl.outputs.veristat_runs_on }}
    steps:
      - id: set-matrix-impl
        shell: python3 -I {0}
        run: |
          from json import dumps
          from enum import Enum
          import os

          class Arch(Enum):
            """
            CPU architecture supported by CI.
            """
            aarch64 = "aarch64"
            s390x = "s390x"
            x86_64 = "x86_64"

          def set_output(name, value):
            """Write an output variable to the GitHub output file."""
            with open(os.getenv("GITHUB_OUTPUT"), "a") as f:
              f.write(f"{name}={value}\n")

          def generate_test_config(test):
            """Create the configuration for the provided test."""
            experimental = test.endswith("_parallel")
            config = {
              "test": test,
              "continue_on_error": experimental,
              # While in experimental mode, parallel jobs may get stuck
              # anywhere, including in user space where the kernel won't detect
              # a problem and panic. We add a second layer of (smaller) timeouts
              # here such that if we get stuck in a parallel run, we hit this
              # timeout and fail without affecting the overall job success (as
              # would be the case if we hit the job-wide timeout). For
              # non-experimental jobs, 360 is the default which will be
              # superseded by the overall workflow timeout (but we need to
              # specify something).
              "timeout_minutes": 30 if experimental else 360,
            }
            return config

          matrix = [
            {"kernel": "LATEST", "runs_on": [], "arch": Arch.x86_64.value, "toolchain": "gcc", "llvm-version": "16"},
            {"kernel": "LATEST", "runs_on": [], "arch": Arch.x86_64.value, "toolchain": "llvm", "llvm-version": "16"},
            {"kernel": "LATEST", "runs_on": [], "arch": Arch.aarch64.value, "toolchain": "gcc", "llvm-version": "16"},
            #{"kernel": "LATEST", "runs_on": [], "arch": Arch.aarch64.value, "toolchain": "llvm", "llvm-version": "16"},
          ]
          self_hosted_repos = [
            "kernel-patches/bpf",
            "kernel-patches/vmtest",
          ]

          for idx in range(len(matrix) - 1, -1, -1):
            if matrix[idx]['toolchain'] == 'gcc':
              matrix[idx]['toolchain_full'] = 'gcc'
            else:
              matrix[idx]['toolchain_full'] = 'llvm-' + matrix[idx]['llvm-version']
          # Only a few repository within "kernel-patches" use self-hosted runners.
          if "${{ github.repository_owner }}" != "kernel-patches" or "${{ github.repository }}" not in self_hosted_repos:
            # Outside of those repositories, we only run on x86_64 GH hosted runners (ubuntu-latest)
            for idx in range(len(matrix) - 1, -1, -1):
              if matrix[idx]["arch"] != Arch.x86_64.value:
                del matrix[idx]
              else:
                matrix[idx]["runs_on"] = ["ubuntu-latest"]
          else:
            # Otherwise, run on (self-hosted, arch) runners
            for idx in range(len(matrix) - 1, -1, -1):
              matrix[idx]["runs_on"].extend(["self-hosted", matrix[idx]["arch"]])

          build_matrix = {"include": matrix}
          set_output("build_matrix", dumps(build_matrix))

          def get_tests(config):
            tests = [
              "test_progs",
              "test_progs_parallel",
              "test_progs_no_alu32",
              "test_progs_no_alu32_parallel",
              "test_maps",
              "test_verifier",
            ]
            if config.get("parallel_tests", True):
              return tests
            return [test for test in tests if not test.endswith("parallel") ]

          test_matrix = {"include": [{**config, **generate_test_config(test)}
                                      for config in matrix
                                      for test in get_tests(config)
                                    ]}
          set_output("test_matrix", dumps(test_matrix))

          veristat_runs_on = next(x['runs_on']
                                  for x in matrix
                                  if x['arch'] == "${{env.veristat_arch}}" and
                                     x['toolchain'] == "${{env.veristat_toolchain}}")
          set_output("veristat_runs_on", veristat_runs_on)
  build:
    name: build for ${{ matrix.arch }} with ${{ matrix.toolchain_full }}
    needs: set-matrix
    runs-on: ${{ matrix.runs_on }}
    timeout-minutes: 100
    strategy:
      fail-fast: false
      matrix: ${{ fromJSON(needs.set-matrix.outputs.build-matrix) }}
    env:
      KERNEL: ${{ matrix.kernel }}
      REPO_ROOT: ${{ github.workspace }}
      REPO_PATH: ""
      KBUILD_OUTPUT: kbuild-output/
    steps:
      - run: echo "would build now"
  test:
    if: ${{ github.event_name != 'push' }}
    name: ${{ matrix.test }} on ${{ matrix.arch }} with ${{ matrix.toolchain_full }}
    needs: [set-matrix, build]
    strategy:
      fail-fast: false
      matrix: ${{ fromJSON(needs.set-matrix.outputs.test-matrix) }}
    runs-on: ${{ matrix.runs_on }}
    timeout-minutes: 100
    env:
      KERNEL: ${{ matrix.kernel }}
      REPO_ROOT: ${{ github.workspace }}
      REPO_PATH: ""
      KBUILD_OUTPUT: kbuild-output/
    steps:
      - if: ${{ matrix.test == 'test_maps' && matrix.arch == 'x86_64' }}
        run: |
          echo "inducing failure"
          false
      - run: echo "would build now"
  veristat:
    name: veristat
    needs: [set-matrix, build]
    runs-on: ${{ fromJSON(needs.set-matrix.outputs.veristat-runs-on) }}
    timeout-minutes: 100
    env:
      KERNEL: LATEST
      REPO_ROOT: ${{ github.workspace }}
      REPO_PATH: ""
      KBUILD_OUTPUT: kbuild-output/
    steps:
      - run: echo "would run veristat now"
